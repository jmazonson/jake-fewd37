<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="deductibleTracker.css" media="screen">
  </head>
  <body>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="../../codeLibraries/d3/d3.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <script src="deductibleTracker_utility.js"></script>
  <script type="text/javascript">
  // function drawDeductibleTracker(width,height,spendToDate,deductible,coinsurance){
var width = 520;
var height = 360;


oopMaxDiv = appendDivCompenentGrpToParent("body","oopMaxDiv",[width/2,height/2])
spendToDateDiv = appendDivCompenentGrpToParent("body","spendToDateDiv",[((width / 2 )),((height / 2))])


//create svg element and append to body
var svg = d3.select("body")
	.append("svg")
  .attr({width:width,height:height})
  .append("g")
var graphComponents = ["emptySlices","filledSlices","labelArcs","labelLines","labelText","labelTicks","oopMaxLine","oopMaxText","spendToDateMoneyCounter"];



for (var i = 0; i < graphComponents.length; i++) {
  appendSvgCompenentGrpToParent(svg,graphComponents[i])
}

svg.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");


 ///---------------- Start the data dicing ------------------///



  function updateGraph(data,width){
    width = width;
    //variables for pie chart-------------//
    // The pie layout is a convenience for computing the start and end angles of arcs that comprise a pie or donut chart:
    var radius = Math.min(width, height) / 2;
    var graphStartAngle = -135;
    var pie = d3.layout.pie()
      //disables sorting (not sure why) the order of the arcs will be the same as what I pass in
      .sort(null)
      .startAngle(graphStartAngle*(Math.PI/180))
      .endAngle(90*(Math.PI/180))
      //Specifies how to extract a value from the associated data might also give data that determines the size of the pie
      .value(function(d) {
        return d.value;
      });
    var key = function(d){ return d.data.section; };


//---------------------Creating the Arcs-----------------------//
    var deductiblePadding = 0.1;
    var labelRadiusAdjust = .9;
    // this is where I set the length of the tick mark
    var tickRadiusAdjust = 0.85;

    //creating arc for the slices
    var arc = d3.svg.arc()
      .outerRadius(radius * 0.8)
      .innerRadius(radius * 0.6)
      .padAngle(function(d) {
        if (key(d)=="coinsurance" || key(d)=="coinsuranceSTD") {
          return deductiblePadding;
        };
        return 0;
      });

      var arcFilled = d3.svg.arc()
        .outerRadius(radius * 0.8)
        .innerRadius(radius * 0.6)
        .padAngle(function(d) {
          if (key(d)=="coinsuranceSTD") {
            return deductiblePadding;
            debugger
          };
          return 0;
        });

    //arc points for tick marks
    var tickArc = d3.svg.arc()
      .innerRadius(radius * tickRadiusAdjust)
      .outerRadius(radius * labelRadiusAdjust)
      .padAngle(function(d) {
        if (key(d)=="coinsurance") {
          return deductiblePadding;
        };
        return 0;
      });

    //creating outer arc for the labelArcs
    var labelArc = d3.svg.arc()
      .innerRadius(radius * labelRadiusAdjust)
      .outerRadius(radius * labelRadiusAdjust)
      .padAngle(function(d) {
        if (key(d)=="coinsurance") {
          return deductiblePadding;
        };
        return 0;
      });


  /* ------- Draw the empty PIE SLICES -------*/
      // a slice is = all the objects in the slice group which at this point is probably empty
      var emptySlice = svg.select(".emptySlices")
        .selectAll("path.emptySlice")
        .data(pie(data.labels), key);
      emptySlice.enter()
        .insert("path")
        .style("fill", "#D5D5D5")
        .attr("class", "emptySlice");
      emptySlice.transition().duration(1000)
      .attrTween("d", function(d) {
        console.log(key(d),"value:",d.value,", startAngle:",d.startAngle,", endAngle:",d.endAngle);
  			this._current = this._current || d;
  			var interpolate = d3.interpolate(this._current, d);
  			this._current = interpolate(0);
  			return function(t) {
  				return arc(interpolate(t));
  			};
  		})
    	emptySlice.exit()
    		.remove();

    /* ------- Draw the FULL PIE SLICES -------*/
        // a slice is = all the objects in the slice group which at this point is probably empty
        var filledSlice = svg.select(".filledSlices")
          .selectAll("path.filledSlice")
          .data(pie(data.filledSlices), key);
        filledSlice.enter()
          .insert("path")
          .style("fill", function(d) { return d.data.color; })
          .attr("class", "filledSlice");
        filledSlice.transition().duration(1000)
        .attrTween("d", function(d) {
          console.log(key(d),"value:",d.value,", startAngle:",d.startAngle,", endAngle:",d.endAngle);
    			this._current = this._current || d;
    			var interpolate = d3.interpolate(this._current, d);
    			this._current = interpolate(0);
    			return function(t) {
    				return arcFilled(interpolate(t));
    			};
    		})
      	filledSlice.exit()
      		.remove();



      /* ------- Draw the label Arcs -------*/
      var labelSlice = svg.select(".labelArcs")
        .selectAll("path.labelArc")
        // for each element in data get the start and end angles of that labelSlice.
        //
        .data(pie(data.labels), key);
      //returns place holders for missing elements enter is for all the new data enter represents the new elements
      //selecting new
      labelSlice.enter()
        // I think insert is like append except it puts it above in the dom rather than under
        // path is the type of element im creating
        .insert("path")
        // make the fill the color associated with that element of the data set
        .style("stroke", function(d) { return d.data.color; })
        .style("opacity","0")
        // make the path be labelSlice class
        .attr("class", "labelArc");
        // set the draw atribute to what the label arc function returns
      labelSlice.attr("d",function(d) {
        //labelArc(d));
        return labelArc(d)
      }).transition().duration(1000).style("opacity",1);
      labelSlice.exit()
        .remove();

        function fadeIn (selection) {
          selection.style("opacity",0);
          selection.transition().duration(1000).style("opacity",1);
        }

      /* ------- Draw the label text -------*/
      var text = svg.select(".labelText")
        .selectAll("text")
        .data(pie(data.labels), key);

      text.enter()
    		.append("text")
    		.attr("dy", ".35em")
        .style("fill",function(d) { return d.data.color; })
        .style("opacity",0)
    		.text(function(d) {
    			return d.data.label;
    		});
      //define function to get the midAngle of slice
      function midAngle(d){
    		return d.startAngle + (d.endAngle - d.startAngle)/2;
    	}
      text.attr("transform",function(d,i) {
        var pos = getLabelTextPosition(d,i)

        return "translate(" + pos[0] + "," + pos[1] + ")";
      })
      .style("text-anchor", function(d){
        return "middle"
      })
      .transition().duration(1000).style("opacity",1);

      function getLabelTextPosition(d,i){
        var yOffSet = -radius;
        var xOffSet = (radius) * (i == 0 ? -1 : 1);
        return [xOffSet,yOffSet]
      }

      /* ------- Label Arc to Text polyline -------*/

      var polyline = svg.select(".labelLines").selectAll("polyline")
          .data(pie(data.labels),key);

      polyline.enter()
        .append("polyline")
        .style("opacity","0");
      polyline.attr("points",function(d,i){
        var pos = labelArc.centroid(d);
        if (i==0) {
          var posText = [getLabelTextPosition(d,i)[0],getLabelTextPosition(d,i)[1]+10];
          var posMiddle =[posText[0],pos[1]]
        }else {
          var posText = [getLabelTextPosition(d,i)[0]-50,getLabelTextPosition(d,i)[1]];
          var posMiddle =[pos[0],posText[1]]
        }

        //TODO:note come back to make this a concatenated string
        return [labelArc.centroid(d),posMiddle,posText];
      })
      .style("stroke", function(d) { return d.data.color; })
      .style("fill","none");
      polyline.transition().duration(1000).style("opacity",1);
      polyline.exit()
        .remove();


      /* ------- Draw the label TICKS -------*/

      //get the tick points by parsing through arc function
      function getTickPoints(data){
        var labelCurveInfoString = tickArc(data);
        var newString=labelCurveInfoString.split(",")
        if (newString.length > 7 ) {
          if (data.data.flag=="Start"){
            //split string at commas into an array
            var newString=labelCurveInfoString.split(",")
            //take the m off of the first entry
            tickPoints = [newString[0].slice(1),newString[1],newString[7].slice(1),newString[8]]
            for (var i = 0; i < tickPoints.length; i++) {
              tickPoints[i]=parseFloat(tickPoints[i])
            }
            return tickPoints;
          }else {
            //parse end of arc points out of string
            //split string at commas into an array
            var newString=labelCurveInfoString.split(",")
            tickpoints = [newString[3].slice(1),
                          newString[4].split("L")[0],
                          newString[4].split("L")[1],
                          newString[5].split("A")[0]]
            for (var i = 0; i < tickPoints.length; i++) {
              tickPoints[i]=parseFloat(tickPoints[i])
            }
            return tickpoints;
          }
        }
      }

      function getArcPoints(data){
        var sliceCurveInfoString = arc(data);
        var newString=sliceCurveInfoString.split(",")
        arcPoints = [newString[2].split(" ")[0],// split at comma, 1st x value [2] with everything before the space
                      newString[4].split("L")[0],
                      newString[4].split("L")[1],
                      newString[4].split("L")[0]]
        for (var i = 0; i < arcPoints.length; i++) {
          arcPoints[i]=parseFloat(arcPoints[i])
        }

        return arcPoints;
          }

      //draw the ticks
      var ticks = svg.select(".labelTicks").selectAll("polyline")
        .data(pie(data.ticks));
      ticks.enter()
        .append("polyline")
        .style("opacity","0")
        .style("stroke", function(d) { return d.data.color; })
      ticks.attr("points", function (d) {
        return getTickPoints(d);
        })
      ticks.transition().duration(1000).style("opacity",1);
        polyline.exit()
          .remove();

    /* ------- Draw the OOP max label-------*/
    // draw a line that is y pixels below the bottom of the last slice
    // and extends out x pixels.  Place right justified text below that
    // .data([data.ticks[data.ticks.length-1]])
    var oopMaxLineXOffSet = 40
    var oopMaxLineYOffSet = 5
    var oopMaxLine = svg.select(".oopMaxLine").selectAll("polyline")
      .data(pie(([data.emptySlices[data.emptySlices.length-1]])));
    oopMaxLine.enter()
      .append("polyline")
      .style("stroke", "#8E8E8E")
      .style("opacity",0);
    oopMaxLine.attr("points", function (d) {
      if (d.value!=0) {
        return [getArcPoints(d)[0]+oopMaxLineXOffSet,
                getArcPoints(d)[1]+oopMaxLineYOffSet,
                getArcPoints(d)[2],
                getArcPoints(d)[3]+oopMaxLineYOffSet];
      }
      })
    oopMaxLine.transition().duration(1000).style("opacity",1);

    var oopMaxText = oopMaxDiv.selectAll("div")
      .data(pie(([data.emptySlices[data.emptySlices.length-1]])));
      oopMaxText.enter()
        .append("div")
        .classed("oopMaxText",true)
        .attr("dy", ".35em")
        .text("Out Of Pocket Maximum:"+ "   " + "$" + data.planInfo[3].value)
        .style("opacity","0")
      oopMaxText.style("transform",function (d) {
        if (d.value!=0) {
          return "translate("+getArcPoints(d)[2]+"px,"+
                  (getArcPoints(d)[3]+oopMaxLineYOffSet)+"px)";
            }
          })
      oopMaxText.text("Out Of Pocket Maximum:"+ "   " + "$" + data.planInfo[3].value)
      oopMaxText.transition().duration(1000).style("opacity",1);

  /* ------- Draw the Spend to date counter-------*/
    var spendToDateMoneyCounter = svg.select(".spendToDateMoneyCounter").selectAll("text")
      .data(data.planInfo);
      spendToDateMoneyCounter.enter()
        .append("text")
        .text("0")
        .style("text-anchor","middle")
        .style("opacity",0)
        .style("fill","#275089");
      //TODO having this conditional seems messy
      spendToDateMoneyCounter.text(function(d,i){if (i == 0){return "$"+d.value}});
      //   var counter = 1;
      //   var interval = setInterval(function(){
      //     spendToDateMoneyCounter.text('$'+counter);
      //     counter += 1;
      //     if (counter > d.value) {
      //       clearInterval(interval);
      //     }
      //   },1);
      //   return "$0";
      // }});
      spendToDateMoneyCounter.transition().duration(1000).style("opacity",1);
      // spendToDateMoneyCounter.transition().duration(1000).text(function(d,i){return d.value});


      var spendToDateText = spendToDateDiv.selectAll("div")
        .data([data.planInfo[0]]);
        spendToDateText.enter()
          .append("div")
          .classed("spendToDateText",true)
          .style("font-size", ".75em")
          .text("Spent to date this year")
          .style("opacity","0")
          .style("text-align","center")
          //TODO reference color from data
          .style("color","#275089")
        spendToDateText.style("transform","0")
        spendToDateText.style("transform","translateY(10px)")

        spendToDateText.transition().duration(1000).style("opacity",1);
        centerAnchorPointHtmlElement(spendToDateDiv);

    }

  updateGraph(generateData(0,0,0,0),window.innerWidth/3);

  var data = generateData(800, 1200, .2, 4900);

  //make graph responsive
  d3.select(window).on('resize', resize);
  function resize(){

    updateGraph(data,window.innerWidth/3);
  }


  setTimeout(function() {   //calls click event after a certain time
    updateGraph(data, window.innerWidth / 3);
  }, 0);


  function generateData(spendToDate, deductible, coinsurance, oopMax) {
    console.log("entering generate Data","std:",spendToDate,"deductible:",deductible,"coinsurance:",coinsurance);
    var deductibleSTD = spendToDate;
    var coinsuranceSTD = 0;
    var totalCoinsurance = oopMax - deductible;
    var remainingDeductible = deductible - spendToDate;
    var remainingCoinsurance = totalCoinsurance - coinsuranceSTD;

    if (spendToDate > deductible) {
      deductibleSTD = deductible;
      coinsuranceSTD = spendToDate - deductible;
      remainingDeductible = 0;
      remainingCoinsurance = totalCoinsurance - coinsuranceSTD;
    }

    return {
      slices: [
        { "section": 'deductibleSTD', "value": deductibleSTD, "color" : "#275089"},
        { "section": 'remainingDeductible', "value": remainingDeductible, "color" : "#D5D5D5"},
        { "section": 'padding', "value": 75, "color" : "#FFF"},
        { "section": 'coinsuranceSTD', "value": coinsuranceSTD, "color" : "#275089"},
        { "section": 'remainingCoinsurance', "value": remainingCoinsurance, "color" : "#D5D5D5"}
      ],

      filledSlices: [
        { "section": 'deductibleSTD', "value": deductibleSTD, "color" : "#275089"},
        { "section": 'remainingDeductible', "value": remainingDeductible, "color" : "#D5D5D5"},
        { "section": 'coinsuranceSTD', "value": coinsuranceSTD, "color" : "#275089"},
        { "section": 'remainingCoinsurance', "value": remainingCoinsurance, "color" : "none"}
      ],

      emptySlices: [
        { "section": 'deductibleSTD', "value": deductibleSTD, "color" : "#275089"},
        { "section": 'deductible', "value": remainingDeductible, "color" : "#D5D5D5"},
        { "section": 'totalCoinsurance', "value": totalCoinsurance, "color" : "#275089"},
        { "section": 'remainingCoinsurance', "value": remainingCoinsurance, "color" : "#D5D5D5"}
      ],

      labels: [
        { "section": 'deductibleLabel', "value": deductible, "color" : "#F17F19", label: "Deductible"},
        { "section": 'coinsurance', "value": totalCoinsurance, "color" : "#56BFDD", label: "Coinsurance"},
      ],

      ticks: [
        { "section": 'deductibleLabel', "value": deductible, "color" : "#F17F19", "flag": "Start"},
        { "section": 'deductibleLabel', "value": deductible, "color" : "#F17F19", "flag": "End"},
        { "section": 'coinsurance', "value": totalCoinsurance, "color" : "#56BFDD", "flag": "Start"},
        { "section": 'coinsurance', "value": totalCoinsurance, "color" : "#56BFDD", "flag": "End"},
      ],

      planInfo:[
        { "section": 'Spent To Date', "value": spendToDate, "color" : "#275089"},
        { "section": 'Deductible', "value": deductible, "color" : "#F17F19"},
        { "section": 'Coinsurance', "value": "80/20", "color" : "#56BFDD"},
        { "section": 'Out Of Pocket Maximum', "value": oopMax, "color" : "#56BFDD"}
      ]
    };
  }

  /* ------- Code for creating random data at intervals-------*/
  // function random(min, max) {
  //   return min + Math.floor(Math.random() * (max - min + 1));
  // }
  // setInterval(function() {   //calls click event after a certain time
  //   var spendToDate = random(300, 800);
  //   var deductible = random(500, 2000);
  //   var coinsurance = random(3000, 5000);
  //   spendToDate = spendToDate > deductible ? deductible : spendToDate;
  //   updateGraph(generateData(spendToDate, deductible, coinsurance), window.innerWidth / 3);
  // }, 3000);

  $(function () {
    $("#deductible, #coinsurance, #spend-to-date, #oopMax")
      .change(function () {
        var spendToDate = parseFloat( $("#spend-to-date").val() );
        var deductible =  parseFloat( $("#deductible").val() );
        var coinsurance = parseFloat( $("#coinsurance").val() );
        var oopMax = parseFloat( $("#oopMax").val() );
        updateGraph(generateData(spendToDate, deductible, coinsurance, oopMax), window.innerWidth / 3);
      });
  });
  //NOTE Padradius would be helpful for the shadow effect
  </script>
  <label>
    Deductible <input type="number" id="deductible" step="100" value="1200" />
  </label>
  <label>
    Coinsurance <input type="number" id="coinsurance" step=".1" value=".2" />
  </label>
  <label>
    Spend to date <input type="number" id="spend-to-date" step="100" value="500" />
  </label>
  <label>
    oopMax <input type="number" id="oopMax" step="100" value="4900" />
  </label>
  </body>
</html>
